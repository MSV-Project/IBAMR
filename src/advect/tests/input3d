// advective term options
CTU_ONLY = -1
SECOND_ORDER = 0
FOURTH_ORDER = 1
MC_LIMITED = 2
MUSCL_LIMITED = 3

// constants
PI = 3.141592653589793e+00

GodunovAdvector {
   limiter_type = MUSCL_LIMITED
}

GodunovHypPatchOps {
   Refinement_data {
      refine_criteria = "QVAL_RICHARDSON", "QVAL_GRADIENT"

      QVAL_RICHARDSON {
         rich_tol = 0.01, 0.01, 0.001
      }
 
      QVAL_GRADIENT {
         grad_tol = 0.1,0.1,0.1
      }
   }
}

QInit {
  init_type = "GAUSSIAN"
  kappa = 0.001

//  init_type = "ZALESAK"
//  zalesak_r = 0.15
//  zalesak_slot_w = 0.025
//  zalesak_slot_l = 0.1

//  X = 0.5, 0.5
}

UInit {
  init_type = "UNIFORM"
  uniform_u = 1.0,-1.0,0.0

//  init_type = "VORTEX"
}

Main {
// log file parameters 
   log_file_name    = "advect3d.log"
   log_all_nodes    = FALSE

// visualization dump parameters 
   viz_writer            = "VisIt"
   viz_dump_interval     = 1          // zero to turn off
   viz_dump_dirname      = "viz_advect3d"
   visit_number_procs_per_file = 1

// restart dump parameters 
   restart_interval        = 0        // zero to turn off
   restart_write_dirname   = "restart_advect3d"

// convergence monitoring parameters
   monitor_convergence = TRUE

// application parameters
//   timestepping = "SYNCHRONIZED"
}

CartesianGeometry {
   domain_boxes = [ (0,0,0) , (64,64,64) ]
   x_lo         =  0, 0, 0    // lower end of computational domain.
   x_up         =  1, 1, 1    // upper end of computational domain.
   periodic_dimension = 1,1,1
}

GriddingAlgorithm {
   max_levels             = 1      // Maximum number of levels in hierarchy.
   ratio_to_coarser {            
      level_1             = 4,4,4  // vector ratio to next coarser level
      level_2             = 4,4,4 
      level_3             = 4,4,4 
   }

   largest_patch_size {
      level_0 = 512,512,512 // largest patch allowed in hierarchy
                         // all finer levels will use same values as level_0...
   }

   smallest_patch_size {
      level_0 =  4, 4, 4 // smallest patch allowed in hierarchy
                         // all finer levels will use same values as level_0...
   }

   efficiency_tolerance   = 0.70e0    // min % of tag cells in new patch level
   combine_efficiency     = 0.85e0    // chop box if sum of volumes of smaller
                                      // boxes < efficiency * vol of large box
//   write_regrid_boxes    = TRUE
   regrid_boxes_filename  = "regrid_boxes"
}

StandardTagAndInitialize {
//   tagging_method = "RICHARDSON_EXTRAPOLATION","GRADIENT_DETECTOR"
//   tagging_method = "RICHARDSON_EXTRAPOLATION"
   tagging_method = "GRADIENT_DETECTOR"
}

HyperbolicLevelIntegrator {
   cfl                      = 0.95e0    // max cfl factor used in problem
   cfl_init                 = 0.95e0    // initial cfl factor
   lag_dt_computation       = TRUE
   use_ghosts_to_compute_dt = FALSE
}

TimeRefinementIntegrator {
   start_time            = 0.e0     // initial simulation time
   end_time              = 1.0      // final simulation time
   grow_dt               = 1.1e0    // growth factor for timesteps
   max_integrator_steps  = 10000    // max number of simulation timesteps
// tag_buffer            = 1,1,1,1  // a max of 4 finer levels in hierarchy
}

LoadBalancer {
   bin_pack_method     = "SPATIAL"
   max_workload_factor = 1
}
